package com.example.demo;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class TestApplication {

	public static void main(String[] args) {
		SpringApplication.run(TestApplication.class, args);
	}

	// 캐릭터들이 살만한 꽃동네를 생성(스프링 빌리지)
	// -> 주민 한명 입주(급하냥)
	// 급하냥의 역할 : 마을의 입구에서 방문객들의 요청을 가장먼저 받아 처리하는 역할
	// -> 컨트롤러를 좀 돌려얘기해봄

	// 시나리오
	// 방문객이 옴.(http://localhost:8080/test1)
	// 마을 입구에서 이것을 확인한 급하냥은 즉시 요청을 접수.
	// 성격이 급한 급하냥은 신속하게 처리하기 위해 미리 준비해둔 test.html을
	// 방문객에게 보여줌(view단 호출)
	// 방문객은 응답으로 test.html파일을 볼수 있음

	// 시나리오 2
	// 생각보다 스프링빌리지에 방문객이 많아졌음
	// 방문객들이 많아지다 보니 서로 소식을 전할 주민 게시판 요청이 들어옴.
	// 급하냥(컨트롤러)의 업무부담 증가.
	// -> 급하냥 혼자서 게시판을 만들고 관리하려니까 너무 힘듬.
	// -> 환영인사에만 집중하고 글을 받아서 내용을 분석하고 창고에 안전하게
	// 보관하는 일까지 하기위한 전문가를 초빙.

	// 급하냥은 자신의 일을 도와줄 두명의 전문가 친구를 초빙.
	// 와플곰 : 요청의 핵심을 파악하고 실질적인 업무를 처리하는 서비스 전문가(@Service)
	// 카피바라 : 데이터를 창고에 안전하게 보관하고 꺼내오는 담당자
	// -> DB에 안전하게 보관하고 꺼내오는 데이터 전문가.

	// 사실 이 모든일들은 급하냥(컨트롤러)이 혼자 처리하는거 가능.
	// -> 하지만 급하냥, 와플곰, 카피바라가 각자 영역들을 문제없이 처리해 준다면
	// 더 효율적인 업무처리가 가능.

	// -> 어디든 운영을 할때 덩치(체급)이 커지면 관리자, 실무자 등등 구분하는것처럼
	// 스프링에서도 컨트롤러 서비스 db 등을 각자 분할하여 처리.

	// 시나리오 3
	// 페이지 상세보기, 게시글 수정, 삭제.

	// 급하냥(컨트롤러)이 여태껏 보여줬던건 게시글 전체 내용일뿐
	// -> 정해진 주소로 오는 요청만 처리.
	// 상세 보기가 필요해진 지금 주소 자체에 정보가 담겨오는 요청도 처리할필요가 있음.
	// -> URL에 포함된 숫자를 정확히 파악하여 서비스단(와플곰)에 요청을 넘겨줄거임
	// (와플곰아 1번 게시글 가져와줘), 2,3번도 유동적으로 사용자에 요청에따라
	// 처리할수 있음.

	// 시나리오 4
	// 회원가입, 로그인, 로그아웃 구현하기.
	// 여기저기 몰려와서 방명록 남기고 그러다보니 조금더 체계적인 관리를 진행할필요가 생김
	// 정식으로 등록된 주민(사용자), 방문객을 구분할 예정
	// 주민들에게만 특정한 권한을 부여할 예정. -> 이런것들을 처리하기위해 스프링 시큐리티 도입.

	// 시큐리티 시스템은 두가지의 핵심적인 일을 진행함.
	// -> 시큐리티는 경비견 누렁이가 담당할거임.

	// 1. 인증(Authentication) : 멍멍 신분증 보여주개!
	// - 마을(스프링 시스템)에 들어오려는 사람이 누구인지 확인하는 과정.
	// - 사용자가 아이디와 비밀번호를 제출(로그인)하면 누렁이가
	// db에 등록된 정보와 일치하는지 확인.

	// 2. 인가(Authorization) : 마을사람이지만 여기는 출입 통제 구역이개.
	// 여기는 프라이빗 룸이개.
	// - 신원이 확인된 사람이라 해도 모든것을 할수 있는게 아니다 라는 얘기.
	// - 해당 행동에 대한 권한이 있는지를 확인하는 과정.
	// - 예를들어 게시글 작성은 주민등급만 가능하고 마을 관리는 마을 이장 등급만 가능하도록 설정.

	// 과거에는 이런것들을 코딩하려면 개발자가 직접 체계를 잡아 쿠키와 세션관리를
	// 일일히 해줘야 했기때문에 개복잡.

	// -> 최근에는 스프링 시큐리티를 활용하여 쿠키 세션관리 및 회원 가입등을 쉽게
	// 처리할수 있도록 시큐리티의 도움을 받는 추세.

	// 당장 시큐리티로 뭐할거임?
	// 회원가입, 로그인, 로그아웃 기능 처리.

	// 에러가 났을때는 어떻게 대처해야하는가?
	// 1. 에러 메세지부터 찾아야함.
	// 2. 에러 메세지를 기반으로 아는거면 해결
	// -> 모르는거먼 서칭해야함.
	// 3. 원인 찾았으면 테스트.

	// Bean 객체
	// -> 개발자가 직접 정의한 메서드들을 스프링이 시작될때 자동으로 올리도록 유도하는 객체.
	// ( 스프링 컨테이너에 빈으로 등록하도록 지정하는 역할)
	// -> Bean 객체는 스프링(컨테이너)에 의해 생성되고 관리된다.
	// -> Bean 객체의 경우는 사용자의 url 요청시 불러질수도 있지만.
	// 정확히는 특정한 상황에서 요청이 없더라도 불러지는 메서드 혹은 객체라 할수있음.
	// 쉽게 얘기하자면 spring의 static

	// 시나리오 5
	// 댓글달기.
	// 공지용이 아니라 활발한 커뮤니티성 페이지로 진화.
	// 관계설정
	// 댓글기능을 추가.
	// 게시글과 댓글의 관계를 어떻게 설정하느냐
	// 하나의 게시글은 여러개의 댓글을 가질수 있음.
	// 하나의 댓글이 여러개의 게시글을 가질수 있나요?(x)
	// -> 즉 게시글과 댓글은 순서대로 표기하자면 1:N 이라는 관계설정이 필요.

	// 시나리오 6
	// 댓글 수정, 삭제하기
	// -> 댓글은 인증된 사용자들만 댓글을 쓸수 있도록 처리.
	// -> 인가는?(로그인한 사용자들만 댓글을 쓰는것 자체가 인가처리도 완료)
	// -> 댓글을 쓰는것은 인증된 사용자들만 댓글을 쓰는게 맞음.
	// 하지만 댓글의 수정은? -> 당연히 쓴사람만 가능해야하지 않을까?
	// -> 댓글 삭제는? -> 마찬가지 아닌가?
	// 로그인한 사용자가 이 댓글을 직접 쓴사람이 맞는지를 확인하는 작업이
	// 앞으로는 필요할것이다. (권한확인)

	// 시나리오 7
	// 공손한 따봉(추천)
	// 사용자, 게시글
	// -> 한명의 사용자가 여러개의 게시글을 작성할수 있음.
	// 예시 상황
	// -> 사용자 1이 게시글을 보고 추천버튼을 클릭.
	// -> 컨트롤러(급하냥)가 이것을보고 게시글에대한 추천요청이 도착했고
	// 요청자는 유저 1이야 라고 와플곰에게 전달.
	// -> 서비스(와플곰)은 추천 명단을 확인후 없다면 추천처리 완료 메세지를 전달.
	// repo로 넘겨야함.

	// 시나리오 8
	// 파일업로드
	// 사용자들에게 자기 자신을 표현할수 있는 방안을 확장하거나
	// 혹은 적절한 이미지를 업로드함으로써 시스템(서비스)를 더 효율적이고
	// 혹은 상품판매에 유리함을 가져가도록 설계할수 있음.
	// 왠만한 웹 서비스에서는 파일업로드 기능은 필수.
	// -> Stream, 폼에 대해서도 변경이 필요.
	// 특히 파일업로드 다운로드 기능 구현에는 경로 설정과 저장공간에 대한 이해도가 필수.

	// 1. 템플릿 - 폼에 MultipartFile이라는 객체에 담하서 전송.(컨트롤러/급하냥)
	// - 이 객체 안에는 파일의 원본이름, 크기, 내용물등의 정보를 흔히 담음.

	// 2. 컨트롤러에서는 이 내용을 서비스로 잘만 던져주면됨.
	// -첨부파일의 처리는 흔히 서비스단에서 하거나 혹은 파일관련 메서드를 따로만들어 처리.
	// -파일을 외부에서 받아올때는 바이트 코드 타입으로 가져옴 -> (물리적파일)원본 파일로 변경
	// - 파일을 저장할때는 다른사용자와 같은이름의 파일일수 있기때문에
	// 원본의 이름을 따로 저장한후 고유한 이름을 새로 만들어 저장하는것이 안전.
	// - 저장을 하려면 서버의 특정 폴더로 이동.
	// ( 엔티티는 아무것도 안해도됨? - 서버에 저장된 파일의 경로와 고유한 파일이름을 받아야함.)
	// - 브라우저(크롬)가 저장된 이미지를 화면에 보여주려면 서버는 특정한 URL로
	// 요청이 왔을때 실제 파일 저장폴더에서 해당파일을 찾아 보내주는 역할을 해야함.
	// -> 기준은 서버에 저장되어있는 파일의 위치 (정적 리소스 매핑)

	// 시나리오 9
	// 정규표현식(Regular Expreesion)과 유효성 검사(Validation check).

	// 유효성 검사 : 사용자 혹은 받아온 데이터가 적합한지 검증하는 검사 방식.
	// -> 사용자가 내용을 입력했는데 이게 우리 서비스 기준에 맞게 제대로 입력했는지 확인 해봐야 한다.
	// 여태 이런것 없이 잘했는데?
	// -> 지금까지는 쓰는 사람이 우리들 밖에 없었음. 근데 만약 이서비스가 외부에 호스팅되는 상황이 었다면?
	// -> 무의미한 데이터들로 우리의 데이터베이스가 가득차버릴 수 있음.
	// 혹은 이런 상황때문에 무의미한 시스템 에러가 발생 할 수도 있음.

	// 의존성 추가로 다음의 라이브러리가 필요
	// implementation 'org.springframework.boot:spring-boot-starter-validation'
	// BindingResult와 principal을 잘 이용하면 간단하게 강력한 유효성 검사를 만들 수 있음.

	// 유효성검사를 통해 우리 시스템에 맞는 올바른 데이터들만 다루도록 진행.

	// 정규표현식 : 유효성 검사로 처리하기 어려운 양식들을 처리해줄 수 있는 일종의 탐지기.
	// -> 특정한 규칙을 가진 문자열을 찾아내거나 바꾸거나 분리하기 위해 사용하는 문자열 형식의 공식

	// 전화번호를 예를들면 '-'을 쓰는 사람이 있고 안쓰는 사람이 있음.
	// -> 하지만 전원 전화번호를 입력한건 맞지만 컴퓨터의 입장은?

	// 정규표현식으로 할 수 있는것들
	// 전화번호 검증, 이메일 검증, 주민번호 검증 등등
	// -> 일정한 형식을 가진 모든 텍스트들을 검증할 수 있다.

	// 정규표현식의 기본 문법.
	// . : 아무 문자 하나와 일치.
	// * : 앞의 문자가 0번 이상 반복
	// + : 앞의 문자가 1번 이상 반복
	// ? : 앞의 문자가 0번 혹은 1번 나타난다.
	// [] : 괄호 안의 문자 중 하나와 일치.
	// ^ : 문자열의 시작과 일치
	// -> ^안녕 : 안녕 이라는 단어로 시작하는 문자열을 찾아주세요.
	// -> 안녕하세요 : 통과 하이 안녕하세요 : x
	// $ : 문자열의 끝과 일치.
	// -> 안녕$ : 안녕이라는 단어로 끝나는가?
	// \d : 숫자 하나와 일치 [0-9]
	// -> 영문자[a-z], [A-Z]
	// -> 한글[가-힣]
	// \w : 문자 하나와 일치(숫자, 알파벳, _)
	// \s : 공백 하나와 일치(스페이스, 탭, 줄바꿈)
	// {n} : 앞의 문자가 정확히 3번 반복
	// -> \d{3} : 숫자 3개.
	// {n,m} : 앞의 문자가 n번 이상 m번 이하 반복
	// -> \w{2,5} : 문자 2~5개

	// 이메일 정규표현식 패턴.
	// ^ : 문자열이 뒤의 대괄호 패턴으로 시작해야함을 의미.
	// [a-zA-Z0-9] : 영문 대소문자 + 숫자 허용
	// ._%+- <- 대괄호 내부에 있으면 이런 특수문자 사용을 허용하겠다는 의미.
	// + : 이 패턴이 한번 이상 반복될 수 있음을 의미.
	// @ : 이메일이니까 이메일을 구분하는 로컬 / 도메인 파트
	// \\ : 도메인명과 최상위 도메인을 구분하는 . 자체를 표현.
	// -> gmail.com
	// {2,6}$ : 최소 2글자에서 최대 6글자까지의 길이를 허용.
	// $ : 표현식 끝
	// 아래의 패턴이 깰라면 충분히 깰 수 있음.
	String regExp = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$";
	// 자바 기준으로 정규표현식을 활용하기 위해서는 Pattern, Matcher라는 클래스를 활용해서 처리할 필요가 있음.
	Pattern p1 = Pattern.compile(regExp);
	String test1 = "nureong@gamil.com";
	String test2 = "wafflegom@";

	// 입력받은 이메일에 대해 Matcher 클래스를 통해 검사.
//	Matcher m1 = p1.matcher(test1);

	// 정규표현식을 기반으로 검사하는 메서드.
//	if(m1.matches())
//	{
//		System.out.println("합격이에옹");
//	}
	
//	와플곰의 고민: "내 비밀 레시피가 '...[밀가루] 500g에 [계란] 3개를 넣고...'"
//			+ " 이런 식으로 적혀있어. 여기서 대괄호([]) 안에 있는 재료 이름들만 쏙쏙 뽑아서 쇼핑 리스트를 만들고 싶어!"
	
	String recipe = "비밀 반죽: [밀가루] 500g과 [계란] 3개, 그리고 약간의 [사랑]을 넣고 섞어주세요.";
	// [가-힣] : 한글들만 뽑아 내겠다. (한글 글자 하나하나)
	// () : 캡처 그룹생성 (정규표현식에서 일치하는 부분을 추출할 수 있도록 해주는 파트)
	// [] <--- 
	// \\[ <--- 정규표현식에서 대괄호는 특별한 의미가 있음.
	// 그래서 이스케이프 코드를 통해 말그대로 문자 [의 시작을 찾겠다는 의미
	// 결론 : 대괄호 안에 있는 한글들을 추출해주세요.
	Pattern pattern = Pattern.compile("\\[([가-힣]+)\\]");
	Matcher matcher = pattern.matcher(recipe);
		
//    List<String> ingredients = new ArrayList<>();
//    // find(): 패턴과 일치하는 다음 부분을 찾으면 true 반환
//    while (matcher.find()) {
//        // group(1): 첫 번째 괄호 그룹에 해당하는 내용("밀가루", "계란", "사랑")을 가져옴
//        ingredients.add(matcher.group(1));
//    }
	
//    급하냥의 임무: "고객 후기 게시판에 전화번호(010-1234-5678)나 이메일(loopy@village.com)"
//    		+ " 같은 개인정보가 그대로 노출되면 큰일 나! 전화번호는 가운데 4자리를 '***'로,"
//    		+ " 이메일은 아이디 앞 3글자 빼고 전부 ''로 바꿔주는 자동 마스킹 시스템을 만들어줘! 빨리!"
	
//	String review = "배송 최고예요! 제 번호는 010-1234-5678 이고,"
//			+ " 이메일은 loopy@village.com 입니다. 연락주세요!";
//	
//	String phoneReg = "(\\d{3})-(\\d{4})-(\\d{4})";
//	// replaceAll : 정규표현식을 사용하여 텍스트내의 특정 패턴을 찾아 변경.
//	// $1 : phoneReg <- 이 변수에서 첫번째 그룹인 d{3}에 해당하는 부분을 가져옴.
//	String maskedReview = review.replaceAll(phoneReg, "$1-****-$3");
//    String emailRegex = "([a-zA-Z0-9]{3})([a-zA-Z0-9]+)(@[a-zA-Z0-9.-]+\\.[a-zA-Z]+)";
//    maskedReview = maskedReview.replaceAll(emailRegex, "$1****$3");
	
	// 정규표현식 결론
	// -> 몰라도 코딩하는데 조금 불편할 수 있지만 지장은 없음.
	// -> 근데 익숙해지면 텍스트 작업은 겁나 빠르게 처리할 수 있음.
	
	// 시나리오 10
	// 페이징처리 (기존 시나리오 페이징 처리는 폐쇄)
	// 페이지 : 가상의 메모리를 동일한 크기의 블록으로 나눈 단위.
	// 페이징 : CS에서 사용하는 메모리 관리 기법.
	// -> OS가 프로세스에서 사용하는 메모리를 효율적으로 관리하기 위해 사용하는 방법.
	
	// 페이징처리 : UI에 표현되는 대량의 데이터를 차근차근 나누어서 처리하기 위해 사용하는 기법.
	// -> 단순하게 화면에 적절히 표현한다의 문제를 넘어서 서버의 부하나 사용자가 활용할 장치의 부담도 줄일 수 있다.
	
	// 페이징은 도서관과 비유해보면 이해가 쉬워짐
	// 도서관 전체 = 데이터베이스에 저장된 데이터.
	// 한 책장(서가) = 한 페이지에 보여줄 데이터.
	// 도서관 안내원 = Pageable 객체.
	// 책장 목록표 = Page 객체.	
	
	// 시나리오 11
	// REST API(RESTful을 추구해야하는게 맞긴한데.)
	// API의 내부 구조.
	// 클라이언트가 우리 API 주소(URL)를 찾아온 상황.
	// -> 그렇다면 해당 주소를 가진 메서드(API)는 뭘 줘야하지?
	// -> 기본적으로는 어떠한 데이터를 돌려줄지를 고민해봐야한다.
	// -> 프로토콜상 요청과 응답으로 넘기고 받아오는 레시피가 있음
	//    (JSON, YAML)
	
	// JSON (JavaScript Object Notation) 
	// - 데이터를 저장하고 교환하기 위한 텍스트 기반의 경량 데이터 교환 형식
	// - 사람이 읽을 수 있고 시스템에서 구문을 분석 할 수 있는 방식으로 설계.
	
	// - 다양한 프로그래밍 언어에서 활용가능.
	// - 가벼움 (과거에는 XML을 이용 -> 하지만 JSON은 XML보다 간결하고 가볍다.)
	// - XML은 읽는게 개빡침.
	// - XML에 비하면 JSON은 K-V 형태로 구성되어 있어서 인간 친화적.
	// - 텍스트 기반의 전송
	//   (모든 데이터가 텍스트 형식으로 저장되어 있기 떄문에 네트워크 전송에 적합)
	
	// JSON의 기본 문법과 구조
	// 숫자, 문자, boolean, 배열, 객체, null
	
	// 문법 규칙
	// 1. 데이터는 k-v 형태로 표현한다.
	// 2. 키값은 반드시 문자열로 작성한다. ("")
	// 3. 데이터는 콤마로 구분한다.
	// 4. 객체는 중괄호로 배열은 대괄호로 표현한다.
	
	// JSON 사용처
	// 서버와 클라이언트간의 데이터 교환에 가장 많이 사용. (API)
	// 설정정보 저장시(YAML)
	
	// YAML(YAML Ain't Markup Language)
	// -> 데이터 중심의 언어임을 강조하기 위해.
	// 확장자가 .yml, yaml
	
	// JSON의 완전 상위호환.
	// -> 대체 가능할 정도.
	// 설정이나 문서화 작업에 많이 사용.
	
	// Spring profile
	// 개발서버와 운영서버.
	
	// 지금까지의 개발 - 하나의 파일에 모든설정을 기록
	//  - application.properties
	
	// 하지만 개발 환경과 운영환경은 그에 맞는 설정이 있다라는 점을 언제나 알고 있어야 함.
	// 스프링에서는 환경별로 특정한 프로필을 활성하는 기능 또한 제공.
	
	// 시나리오 12
	// DB와 스프링의 연결.
	//  - ORM은 스프링과 DB 세계를 잇는 다리 같은 녀석
	//  - 근데 저 다리를 꼭 건너야함?
	
	// 자바랑 DB를 비교.
	// 1. JAVA
	//  - 자바 내부의 대부분은 객체로 구성되어 있다.
	//  - 객체들은 상속으로 관계를 가질 수 있음.
	//  - 다른 객체를 참조 할 수 있음. (클래스를 변수 타입선언하고 변수 선언하듯이 사용)
	//  - 객체 그래프의 자유로운 탐색.
	//    (인스턴스명.getMethod().getVal())
	
	// 2. DB(Relation Database)
	//  - 테이블 내부의 row로 저장.
	//  - DB에 상속이란 개념을 설명한적 있나요?
	//    (슈퍼타입 서브타입 전략은 있음)
	//  - 다른 테이블의 데이터를 외래키 라는 녀석을 통해 참조가 가능
	//  - 관계 탐색시에는 JOIN 연산이 필요하다.
	
	// 과거에는 이 차이점 때문에 개발자들이 객체를 db에 저장하거나 db에서 데이터를 불러올때 변환하는 작업 자체가 개짜증.
	//  -> 객체와 관계의 임피던스 불일치.
	//     객체지향 프로그래밍과 관계형 DB간의 구조적, 개념적 차이를 설명할 때 얘기하는 개념.
	//      -> 구조간의 차이를 극복하기위해 ORM이 등장
	// JDBC -> ibatis -> mybaits -> QueryDSL, JPQL
	
	// 과거의 ORM 사용
	//  -> 개발자가 직접 변환	
	// String sql = "select * from customers";	
	// String sql = "select * from customers where id=?";
	
	// 우리는 어떻게 db에 저장했는가?
	// 서비스단에서
	// postRepository.save(Entity, dto 객체);
	
	// 시나리오 13
	// 요청받은 데이터를 잘 던지기 위한 API 구축 및 DB와의 연동을 하는 방법을 알아보기
	// 영속성 컨텍스트
	//  -> 엔티티를 영구 저장하는 환경.
	// @Transactional 어노테이션이 붙어 있다면 메서드가 시작될때 생성되고 메서드가 끝날 때 사라지는 논리적인 공간임.
	// 영속성 컨텍스트 법칙 4가지
	// 1차 캐시 : 영속성 컨텍스트는 내부에 Map 형태의 캐시를 가지고 있음.
	//  -> 여기서 key는 엔티티에 선언된 @Id의 값 Value는 엔티티 객체 그 자체가 Value로 묶이게 된다.
	//  -> findById 같은 조회를 진행하면 JPA가 이 엔티티를 1차 캐시 영역에 저장.
	//  -> 만약 동일한 ID로 다시 조회를 요청하면 JPA는 DB에 굳이 요청하지 않고
	//     저장된 엔티티를 리턴.
	//  -> 불필요한 DB 조회가 줄어들다보니 성능 향상에 큰 도움이 된다.	
	// 동일성 보장
	//  -> 똑같은 요청이 들어오면 몇번을 호출하던지 완벽하게 동일한 객체 인스턴스를 
	//     리턴하는 것을 보장. (일관성을 보존)
	// 쓰기 지연(Transactional Write-behind)
	//  -> save 메서드가 호출되어도 JPA는 즉시 INSERT SQL을 DB로 보내지 않음.
	//  -> 생성된 SQL을 SQL 쓰기 지연 저장소라는 내부 공간에 차곡차곡 모아둠.
	//     트랜잭션 커밋이 발동하는 순간 지연저장소에 모아둔 SQL들을 한번에 DB로 전송.
	//  -> IDENTITY가 걸려있을 경우는 트랜잭션 상관없이 그냥 SAVE 동작하는 순간 바로 저장됨.
	// 변경 감지 : 엔티티 상태만 변경하면 DB 업데이트도 알아서!
	//  -> 자동 업데이트.
	
	// 엔티티의 생명주기(라이프 사이클)
	// 1. 비영속 : 객체 생성만 된 상태 DB와는 무관한 상태 new Entity()
	// 2. 영속 : save. findById 같은 메서드들을 통해 영속성 컨텍스트라는 것의 관리를 받게된 상태. 
	// 3. 준영속 : 영속성 컨텍스트가 관리하던 엔티티였으나 컨텍스트가 종료되거나 개발자가 특정한 메서드를 호출하여 더 이상 관리하지 않는 상태
	//           -> 변경감지나 지연로딩같은 기능들을 활용 할 수 없음.
	// 4. 삭제 : 삭제 요청이 진행된 상태.
	
	// 실전에서는 어떻게 쓰일까?
	// 앞서 언급한 내용들은 @Transactional로 감싸진 범위 내에서만 일어난다는점.
	// 특히나 변경감지는 트랜잭션이 끝나고 커밋될때 동작함.
	//  -> 가급적이면 데이터의 수정이 포함된 로직은 반드시 @Transactional 어노테이션이 붙은 서비스 메서드 내부에서 처리하는것이 좋다.
	
	// 그래서 현업은 조회할때도 DTO를 잘 쓰는게 보안상으로도 굉장히 유리.
	//  -> 다만 데이터 수정시에는 DTO로 객체 내용들 받아다가 원본 엔티티로 동작시켜서 변경 감지 기능에 동작을 유도하는 방안도 나쁘지않다.
	
	
	
	
	
	
	
	
	

}